# Add MiniKit

> Wrap your app with MiniKitProvider and initialize the frame

Add the provider and initialize MiniKit in your main page.

## Add MiniKitProvider

Create `providers/MiniKitProvider.tsx` and wrap `app/layout.tsx`.

```jsx providers/MiniKitProvider.tsx
'use client';
import { MiniKitProvider } from '@coinbase/onchainkit/minikit';
import { ReactNode } from 'react';
import { base } from 'wagmi/chains';

export function MiniKitContextProvider({ children }: { children: ReactNode }) {
  return (
    <MiniKitProvider apiKey={process.env.NEXT_PUBLIC_CDP_CLIENT_API_KEY} chain={base}>
      {children}
    </MiniKitProvider>
  );
}
```

Wrap your root layout:

```jsx app/layout.tsx
import { MiniKitContextProvider } from '@/providers/MiniKitProvider';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang='en'>
      <body>
        <MiniKitContextProvider>{children}</MiniKitContextProvider>
      </body>
    </html>
  );
}
```

## Initialize MiniKit in your page

Use `useMiniKit()` to call `setFrameReady()` when your app is ready.

```jsx app/page.tsx
'use client';
import { useEffect } from 'react';
import { useMiniKit } from '@coinbase/onchainkit/minikit';

export default function HomePage() {
  const { setFrameReady, isFrameReady } = useMiniKit();

  useEffect(() => {
    if (!isFrameReady) setFrameReady();
  }, [isFrameReady, setFrameReady]);

  return <div>Your app content goes here</div>;
}
```

<Tip>
  The provider configures wagmi and react‑query and uses the Farcaster connector when available.
</Tip>
# Configure Environment

> Add required and optional environment variables for MiniKit

Add required variables to your local and deployment environments.

<Tabs>
  <Tab title="Required Variables">
    These variables are essential for your MiniKit app to function:

    <ParamField path="NEXT_PUBLIC_ONCHAINKIT_PROJECT_NAME" type="string" required>
      The name of your Mini App as it appears to users
    </ParamField>

    <ParamField path="NEXT_PUBLIC_URL" type="string" required>
      The deployed URL of your application (must be HTTPS)
    </ParamField>

    <ParamField path="NEXT_PUBLIC_ONCHAINKIT_API_KEY" type="string" required>
      Your Coinbase Developer Platform API key
    </ParamField>

    <ParamField path="FARCASTER_HEADER" type="string" required>
      Generated during manifest creation for account association
    </ParamField>

    <ParamField path="FARCASTER_PAYLOAD" type="string" required>
      Generated during manifest creation for account association
    </ParamField>

    <ParamField path="FARCASTER_SIGNATURE" type="string" required>
      Generated during manifest creation for account association
    </ParamField>
  </Tab>

  <Tab title="Optional Variables">
    These variables enhance your app's appearance and metadata:

    <ParamField path="NEXT_PUBLIC_APP_ICON" type="string">
      URL to your app's icon (recommended: 48x48px PNG)
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_SUBTITLE" type="string">
      Brief subtitle shown in app listings
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_DESCRIPTION" type="string">
      Detailed description of your app's functionality
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_SPLASH_IMAGE" type="string">
      URL to splash screen image shown during app loading
    </ParamField>

    <ParamField path="NEXT_PUBLIC_SPLASH_BACKGROUND_COLOR" type="string">
      Hex color code for splash screen background (e.g., "#000000")
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_PRIMARY_CATEGORY" type="string">
      Primary category for app discovery (e.g., "social", "gaming", "utility")
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_HERO_IMAGE" type="string">
      Hero image URL displayed in cast previews
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_TAGLINE" type="string">
      Short, compelling tagline for your app
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_OG_TITLE" type="string">
      Open Graph title for social sharing
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_OG_DESCRIPTION" type="string">
      Open Graph description for social sharing
    </ParamField>

    <ParamField path="NEXT_PUBLIC_APP_OG_IMAGE" type="string">
      Open Graph image URL for social media previews
    </ParamField>
  </Tab>
</Tabs>

### Copy-paste .env example

```bash Terminal
# Required
NEXT_PUBLIC_ONCHAINKIT_PROJECT_NAME=YourAppName
NEXT_PUBLIC_URL=https://your-app.vercel.app
NEXT_PUBLIC_ONCHAINKIT_API_KEY=your_cdp_client_api_key

# Generated by `npx create-onchain --manifest`
FARCASTER_HEADER=base64_header
FARCASTER_PAYLOAD=base64_payload
FARCASTER_SIGNATURE=hex_signature

# Optional (appearance and metadata)
NEXT_PUBLIC_APP_ICON=https://your-app.vercel.app/icon.png
NEXT_PUBLIC_APP_SUBTITLE=Short subtitle
NEXT_PUBLIC_APP_DESCRIPTION=Describe what your app does
NEXT_PUBLIC_APP_SPLASH_IMAGE=https://your-app.vercel.app/splash.png
NEXT_PUBLIC_SPLASH_BACKGROUND_COLOR=#000000
NEXT_PUBLIC_APP_PRIMARY_CATEGORY=social
NEXT_PUBLIC_APP_HERO_IMAGE=https://your-app.vercel.app/og.png
NEXT_PUBLIC_APP_TAGLINE=Play instantly
NEXT_PUBLIC_APP_OG_TITLE=Your App
NEXT_PUBLIC_APP_OG_DESCRIPTION=Fast, fun, social
NEXT_PUBLIC_APP_OG_IMAGE=https://your-app.vercel.app/og.png
```

<Warning>
  Ensure all referenced assets are publicly accessible via HTTPS.
</Warning>
# Manifest (CLI)

> Generate account association credentials with the CLI

Generate your Farcaster account association credentials.

```bash Terminal
npx create-onchain --manifest
```

Follow the prompts to connect your Farcaster custody wallet, add your deployed URL, and sign. The CLI writes `FARCASTER_HEADER`, `FARCASTER_PAYLOAD`, and `FARCASTER_SIGNATURE` to your `.env`.

<Warning>
  While testing, set `noindex: true` in your manifest to avoid indexing.
</Warning>
# Create Manifest

> Expose the required /.well-known/farcaster.json endpoint

Your Mini App's Manifest proves ownership of your app and powers search, discovery, and rich embeds in the Base App.

Below we'll create a Next.js route at `app/.well-known/farcaster.json/route.ts` that returns your accountAssociation and frame metadata.

<Check>
  Visit `https://yourdomain.com/.well-known/farcaster.json` to verify JSON output.
</Check>

```ts app/.well-known/farcaster.json/route.ts
function withValidProperties(properties: Record<string, undefined | string | string[]>) {
  return Object.fromEntries(
    Object.entries(properties).filter(([_, value]) => (Array.isArray(value) ? value.length > 0 : !!value))
  );
}

export async function GET() {
  const URL = process.env.NEXT_PUBLIC_URL as string;
  return Response.json({
    accountAssociation: {
      header: process.env.FARCASTER_HEADER,
      payload: process.env.FARCASTER_PAYLOAD,
      signature: process.env.FARCASTER_SIGNATURE,
    },
    frame: withValidProperties({
      version: '1',
      name: process.env.NEXT_PUBLIC_ONCHAINKIT_PROJECT_NAME,
      subtitle: process.env.NEXT_PUBLIC_APP_SUBTITLE,
      description: process.env.NEXT_PUBLIC_APP_DESCRIPTION,
      screenshotUrls: [],
      iconUrl: process.env.NEXT_PUBLIC_APP_ICON,
      splashImageUrl: process.env.NEXT_PUBLIC_APP_SPLASH_IMAGE,
      splashBackgroundColor: process.env.NEXT_PUBLIC_SPLASH_BACKGROUND_COLOR,
      homeUrl: URL,
      webhookUrl: `${URL}/api/webhook`,
      primaryCategory: process.env.NEXT_PUBLIC_APP_PRIMARY_CATEGORY,
      tags: [],
      heroImageUrl: process.env.NEXT_PUBLIC_APP_HERO_IMAGE,
      tagline: process.env.NEXT_PUBLIC_APP_TAGLINE,
      ogTitle: process.env.NEXT_PUBLIC_APP_OG_TITLE,
      ogDescription: process.env.NEXT_PUBLIC_APP_OG_DESCRIPTION,
      ogImageUrl: process.env.NEXT_PUBLIC_APP_OG_IMAGE,
      // use only while testing
      noindex: true,
    }),
  });
}
```

Review the full [Manifest guide](/mini-apps/features/manifest) and update all fields. Be sure to update your deployment environment with these values.
# Add Frame Metadata

> Define fc:frame metadata to render rich embeds with launch buttons

Metadata is critical for your app to be discovered. It enables rich embeds shared in the social feed and allows it to be properly indexed.Add `fc:frame` metadata so shared links render an embed with a launch button.

<Frame caption="Metadata enables rich embeds and discovery">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/base-a060aa97/images/minikit/social_finding.gif" alt="Image of social feed with Mini Apps" />
</Frame>

<Warning>
  Place the meta tag in `<head>` and ensure all referenced assets use HTTPS.
</Warning>

### Next.js (generateMetadata)

```ts app/layout.tsx
export async function generateMetadata(): Promise<Metadata> {
  const URL = process.env.NEXT_PUBLIC_URL as string;
  return {
    title: process.env.NEXT_PUBLIC_ONCHAINKIT_PROJECT_NAME,
    description: 'Generated by `create-onchain --mini`',
    other: {
      'fc:frame': JSON.stringify({
        version: 'next',
        imageUrl: process.env.NEXT_PUBLIC_APP_HERO_IMAGE,
        button: {
          title: `Launch ${process.env.NEXT_PUBLIC_ONCHAINKIT_PROJECT_NAME}`,
          action: {
            type: 'launch_frame',
            name: process.env.NEXT_PUBLIC_ONCHAINKIT_PROJECT_NAME,
            url: URL,
            splashImageUrl: process.env.NEXT_PUBLIC_SPLASH_IMAGE,
            splashBackgroundColor: process.env.NEXT_PUBLIC_SPLASH_BACKGROUND_COLOR,
          },
        },
      }),
    },
  };
}
```
# Common Issues & Debugging

> Frequent issues encountered during Mini App development and their solutions

## Prerequisites & Setup Verification

Ensure your Mini App has the foundational requirements in place.

### Required Files and Structure

```text
your-domain.com/
├── .well-known/
│   └── farcaster.json          # Required manifest file
├── your-app/
│   ├── index.html              # Your app entry point
│   └── ...                     # Your app files
```

### Environment Setup Checklist

* Domain is accessible via HTTPS
* Manifest file exists at `/.well-known/farcaster.json`
* All image URLs are publicly accessible

### Basic Validation Steps

1. Test manifest accessibility: visit `https://yourdomain.com/.well-known/farcaster.json`
2. Validate JSON syntax with JSONLint
3. Ensure your app loads without console errors

## Quick Diagnostic Workflow

* Not appearing in search? → App Discovery & Indexing Issues
* Not rendering as an embed? → Embed Rendering Issues
* Wallet connection problems? → Wallet Connection Problems
* Need mobile testing tools? → Mobile Testing & Debugging
* Changes not appearing? → Manifest Configuration Problems
* App closes on gestures? → Gesture Conflicts and App Dismissal Issues

## Detailed Problem Solutions

### 1. App Discovery & Indexing Issues

Problem: Your Mini App doesn't appear in search results or app catalogs.

Root cause: Missing or incomplete manifest configuration.

Solution: Ensure your manifest includes all required fields (see Manifest feature guide).

Critical requirements:

* `primaryCategory` is required for searchability and category pages
* `accountAssociation` is required for verification

App Indexing Requirements:

1. Complete your manifest setup
2. Share your Mini App URL in a post
3. Indexing can take up to 10 minutes
4. Verify appearance in app catalogs

Caching Issues — Changes Not Appearing:

Farcaster clients may cache manifest data for up to 24 hours. Re‑share to trigger a refresh and allow \~10 minutes.

### 2. Manifest Configuration Problems

Image Display Issues:

1. Test image accessibility in incognito
2. Verify image format (PNG, JPG, WebP supported)
3. Check dimensions
4. Ensure HTTPS URLs only

### 3. Embed Rendering Issues

Problem: Your Mini App URL doesn't render as a rich embed when shared.

Root cause: Incorrect or missing `fc:frame` metadata.

Solution: Use `name="fc:frame"` meta tag in `<head>` and validate using the Embed Tool.

### 4. Wallet Connection Problems

Prefer MiniKit with OnchainKit Wallet or Wagmi hooks. MiniKit includes wagmi providers; avoid double configuration.

### 5. Gesture Conflicts and App Dismissal Issues

Disable native gestures when calling ready if you use swipe/drag interactions:

```ts App.tsx
await sdk.actions.ready({ disableNativeGestures: true });
```

### 6. Mobile Testing & Debugging

**Eruda Mobile Console Setup:**

Add Eruda for mobile console debugging during development:

```tsx App.tsx
import { useEffect } from 'react';

export default function App() {
  useEffect(() => {
    // Only load Eruda in development and not on localhost
    if (typeof window !== 'undefined' && 
        process.env.NODE_ENV === 'development' && 
        !window.location.hostname.includes('localhost')) {
      import('eruda').then((eruda) => eruda.default.init());
    }
  }, []);

  return (
    <div>
      {/* Your app content */}
    </div>
  );
}
```

**Mobile Testing Workflow:**

1. Deploy to production or use ngrok for local testing
2. Share the mini app in a Farcaster DM to yourself
3. Open in mobile client (Base App, Farcaster)
4. Use Eruda console for debugging on mobile
5. Test across multiple clients for compatibility

**Testing Checklist:**

* [ ] App loads correctly on mobile devices
* [ ] Touch interactions work properly
* [ ] Viewport is correctly sized
* [ ] Images load and display correctly
* [ ] Console shows no critical errors

## Advanced Troubleshooting

**CBW Validator Tool:**

Use the Coinbase Wallet validator for Base App compatibility analysis. This AI-powered tool can identify unsupported patterns and suggest improvements.

**Complete Manifest Example:**

```json farcaster.json
{
  "accountAssociation": {
    "header": "your-farcaster-header",
    "payload": "your-farcaster-payload", 
    "signature": "your-farcaster-signature"
  },
    "baseBuilder": {
    "allowedAddresses": ["0x..."]
  },
  "frame": {
    "name": "Your Mini App",
    "iconUrl": "https://yourapp.com/icon.png",
    "homeUrl": "https://yourapp.com",
    "imageUrl": "https://yourapp.com/og.png",
    "buttonTitle": "Launch App", 
    "description": "Your app description under 130 characters",
    "primaryCategory": "social",
    "tags": ["tag1", "tag2"]
  }
}
```

## Success Verification

Basic functionality and discovery/sharing checklists: confirm load, images, wallet, manifest endpoint, embed rendering, and search presence.

## Getting Additional Help

* Mini App Debug Tool
* Mini App Embed Tool
* JSONLint
* Eruda
* Base Discord — #minikit channel
